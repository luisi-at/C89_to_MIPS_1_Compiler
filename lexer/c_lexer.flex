%option noyywrap
%option yylineno

%{
/* C embedded into autogenerated code goes here,
need to include any header files that may be needed */

#include "c_lexer.hpp"

// need to work on the preprocessor stuff

%}

/* Definitions as defined by the C89/C90 Specification */

delim                         [ \t\r]
carriage_return               [\n]
whitespace                    {delim}+

nondigit                      [_a-zA-Z]
digit                         [0-9]
sign                          [+|-]

nonzero_digit                 [1-9]
octal_digit                   [0-7]
hexadecimal_digit             [0-9a-fA-F]
unsigned_suffix               [uU]
long_suffix                   [lL]
exponent                      [eE]
floating_suffix               [flFL]

identifier                    {nondigit}+({nondigit}+|{digit}+)*

decimal_constant              {nonzero_digit}+{digit}*
octal_constant                0{octal_digit}*
hexadecimal_constant          (0x|0X){hexadecimal_digit}+
integer_constant              ({decimal_constant}({unsigned_suffix}|{long_suffix})?)|({octal_constant}({unsigned_suffix}|{long_suffix})?)|({hexadecimal_constant}({unsigned_suffix}|{long_suffix})?)

digit_sequence                {digit}+
fractional_constant           {digit_sequence}\\.{digit_sequence}
exponent_part                 {exponent}{sign}?{digit_sequence}
floating_constant             ({fractional_constant}{exponent_part}?{floating_suffix}?)|({digit_sequence}{exponent_part}{floating_suffix}?)

enumeration_constant          {identifier}

simple_escape_sequence        (\\)['"?\\abfnrtv]
octal_escape_sequence         \\{octal-digit}+
hexadecimal_escape_sequence   \\{hexadecimal_digit}+

character_constant            (\'[^\'\\\n]+\')|(L\'[^\'\\\n]+\')

/* s_char_sequence essentially takes the c_char sequence but bundles it within quotation marks */
/* this may need further investigation */
string_literal                (\"[^\'\\\n]*\")

operator_square               (\[).*(\])
operator_parenthesis          \(.*\)
operator_brackets             (\{).*(\})
single_operator               [&*+-~!\^|,:;=#%<>]
operator                      {single_operator}|{operator_square}|{operator_parenthesis}|{operator_brackets}
/* are there more ^^? */

%%

{whitespace}                  {/* consume the whitespace */}

{hexadecimal_constant}        {yylval.value = new std::string(yytext); return Constant;} //return constant and the value

{integer_constant}            {yylval.value = new std::string(yytext); return Constant;}

{floating_constant}           {yylval.value = new std::string(yytext); return Constant;}

{character_constant}          {yylval.value = new std::string(yytext); return Constant;} //return constant and value

{string_literal}              {yylval.value = new std::string(yytext); return StringLiteral;} //return constant and value

auto                          {yylval.value = new std::string(yytext); return Keyword;}
double                        {yylval.value = new std::string(yytext); return Keyword;}
int                           {yylval.value = new std::string(yytext); return Keyword;}
struct                        {yylval.value = new std::string(yytext); return Keyword;}
break                         {yylval.value = new std::string(yytext); return Keyword;}
else                          {yylval.value = new std::string(yytext); return Keyword;}
long                          {yylval.value = new std::string(yytext); return Keyword;}
switch                        {yylval.value = new std::string(yytext); return Keyword;}
case                          {yylval.value = new std::string(yytext); return Keyword;}
enum                          {yylval.value = new std::string(yytext); return Keyword;}
register                      {yylval.value = new std::string(yytext); return Keyword;}
typedef                       {yylval.value = new std::string(yytext); return Keyword;}
char                          {yylval.value = new std::string(yytext); return Keyword;}
extern                        {yylval.value = new std::string(yytext); return Keyword;}
return                        {yylval.value = new std::string(yytext); return Keyword;}
union                         {yylval.value = new std::string(yytext); return Keyword;}
const                         {yylval.value = new std::string(yytext); return Keyword;}
float                         {yylval.value = new std::string(yytext); return Keyword;}
short                         {yylval.value = new std::string(yytext); return Keyword;}
unsigned                      {yylval.value = new std::string(yytext); return Keyword;}
continue                      {yylval.value = new std::string(yytext); return Keyword;}
for                           {yylval.value = new std::string(yytext); return Keyword;}
signed                        {yylval.value = new std::string(yytext); return Keyword;}
void                          {yylval.value = new std::string(yytext); return Keyword;}
default                       {yylval.value = new std::string(yytext); return Keyword;}
goto                          {yylval.value = new std::string(yytext); return Keyword;}
sizeof                        {yylval.value = new std::string(yytext); return Keyword;}
volatile                      {yylval.value = new std::string(yytext); return Keyword;}
do                            {yylval.value = new std::string(yytext); return Keyword;}
if                            {yylval.value = new std::string(yytext); return Keyword;}
static                        {yylval.value = new std::string(yytext); return Keyword;}
while                         {yylval.value = new std::string(yytext); return Keyword;}

{identifier}                  {yylval.value = new std::string(yytext); return Identifier;} //return identifier

"++"                          {yylval.value = new std::string(yytext); return Operator;}
"--"                          {yylval.value = new std::string(yytext); return Operator;}
"+="                          {yylval.value = new std::string(yytext); return Operator;}
"-="                          {yylval.value = new std::string(yytext); return Operator;}
"*="                          {yylval.value = new std::string(yytext); return Operator;}
"/="                          {yylval.value = new std::string(yytext); return Operator;}
"%="                          {yylval.value = new std::string(yytext); return Operator;}
"&="                          {yylval.value = new std::string(yytext); return Operator;}
"|="                          {yylval.value = new std::string(yytext); return Operator;}
"^="                          {yylval.value = new std::string(yytext); return Operator;}
"<<="                         {yylval.value = new std::string(yytext); return Operator;}
">>="                         {yylval.value = new std::string(yytext); return Operator;}
"<>"                          {yylval.value = new std::string(yytext); return Operator;}
"<="                          {yylval.value = new std::string(yytext); return Operator;}
">="                          {yylval.value = new std::string(yytext); return Operator;}
"=="                          {yylval.value = new std::string(yytext); return Operator;}
"!="                          {yylval.value = new std::string(yytext); return Operator;}
"&&"                          {yylval.value = new std::string(yytext); return Operator;}
"||"                          {yylval.value = new std::string(yytext); return Operator;}
"<<"                          {yylval.value = new std::string(yytext); return Operator;}
">>"                          {yylval.value = new std::string(yytext); return Operator;}
"->"                          {yylval.value = new std::string(yytext); return Operator;}

{operator}                    {yylval.value = new std::string(yytext); return Operator;} //return operator

{carriage_return}             {return StreamlineUpdate;}

.                             {yylval.value = new std::string(yytext); return Invalid;}
%%

/* Error handler. This will get called if none of the rules match. */
void yyerror (char const *s)
{
  fprintf (stderr, "Flex Error: %s\n", s); /* s is the text that wasn't matched */
  exit(1);
}
